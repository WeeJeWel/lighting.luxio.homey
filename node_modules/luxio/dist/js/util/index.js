'use strict';

var msleep = function () {
	var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(timeout) {
		return regeneratorRuntime.wrap(function _callee$(_context) {
			while (1) {
				switch (_context.prev = _context.next) {
					case 0:
						return _context.abrupt('return', new Promise(function (resolve, reject) {
							setTimeout(function () {
								return resolve();
							}, timeout);
						}));

					case 1:
					case 'end':
						return _context.stop();
				}
			}
		}, _callee, this);
	}));

	return function msleep(_x) {
		return _ref2.apply(this, arguments);
	};
}();

var timeoutAfter = function () {
	var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(timeout) {
		return regeneratorRuntime.wrap(function _callee2$(_context2) {
			while (1) {
				switch (_context2.prev = _context2.next) {
					case 0:
						_context2.next = 2;
						return msleep(timeout);

					case 2:
						throw new Error('Timeout');

					case 3:
					case 'end':
						return _context2.stop();
				}
			}
		}, _callee2, this);
	}));

	return function timeoutAfter(_x2) {
		return _ref3.apply(this, arguments);
	};
}();

var timeoutRace = function () {
	var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(promise, timeout) {
		return regeneratorRuntime.wrap(function _callee3$(_context3) {
			while (1) {
				switch (_context3.prev = _context3.next) {
					case 0:
						return _context3.abrupt('return', Promise.race([promise, timeoutAfter(timeout)]));

					case 1:
					case 'end':
						return _context3.stop();
				}
			}
		}, _callee3, this);
	}));

	return function timeoutRace(_x3, _x4) {
		return _ref4.apply(this, arguments);
	};
}();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

var tinygradient = require('tinygradient');

function createGradient(_ref) {
	var source = _ref.source,
	    pixels = _ref.pixels;

	if (!Array.isArray(source)) throw new Error('Invalid type for createGradient, expected: Array');

	// add # to color
	var colors = source.map(function (color) {
		if (color.charAt(0) !== '#') return '#' + color;
		return color;
	});

	// at least 2 colors
	if (colors.length === 1) colors.push(colors[0]);

	return tinygradient(colors).rgb(pixels).map(function (color) {
		return color.toString('hex').substring(1).toUpperCase();
	});
}

/*
	Get a color temperature, based on cool (0) or warm (1)
*/
function getColorTemperature(temperature) {
	if (temperature < 0 || temperature > 1) throw new Error('Color Temperature is out of bounds');

	var gradient = tinygradient('#CCFBFD', '#FFFFFF', '#FFDA73').hsv(99);
	var color = gradient[Math.floor(temperature * 98)];
	return color.toHexString().substring(1) // remove #
	.toUpperCase();
}

module.exports = {
	msleep: msleep,
	timeoutAfter: timeoutAfter,
	timeoutRace: timeoutRace,
	createGradient: createGradient,
	getColorTemperature: getColorTemperature
};

if (typeof window !== 'undefined') {
	module.exports.fetch = require('./fetch.js');
} else {
	module.exports.fetch = require('node-fetch');
}